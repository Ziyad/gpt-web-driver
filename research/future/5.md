To achieve "state-level" stealth—the kind that survives months of daily use—you must move beyond simulating **Input Physics** (how the mouse moves) to simulating **Cognitive Intent** (why the mouse moves) and **Environmental Integrity** (where the browser lives).

Here are the advanced "Missing Link" techniques that separate a sophisticated script from a biological user.

### 1. The "Cognitive Input" Strategy (Paste vs. Type)

**The Flaw:** Bots treat all text equally. They type a 50-character query and a 4,000-character code block at the same speed.
**The Human Reality:** Humans type short queries but **paste** long context. Typing 2,000 characters manually without a single backspace or pause is a statistical anomaly.

**The Fix:** Implement a **Hybrid Input Gate**.

* **Length < 300 chars:** Type manually using the `NeuromotorMouse` (from previous answer).
* **Length > 300 chars:** Simulate a `Ctrl+V` (Paste) operation.

**Implementation (The "Dirty" Clipboard):**
Do *not* use `page.keyboard.send_keys("Control+V")` via CDP. You must populate the OS clipboard first, then trigger the hardware keystrokes with human latency.

```python
import pyperclip
import pyautogui
import platform
import asyncio
import random

async def smart_enter_text(text):
    if len(text) < 300:
        # Use your existing Neuromotor typer for short prompts
        await cognitive_typer.type_text(text)
    else:
        # 1. Populate OS Clipboard (looks like an external copy)
        pyperclip.copy(text)
        await asyncio.sleep(random.uniform(0.5, 1.5)) # "Alt-Tab" time
        
        # 2. Perform the Paste Chord
        ctrl = 'command' if platform.system() == 'Darwin' else 'ctrl'
        
        # Hold modifier first, then 'v'
        with pyautogui.hold(ctrl):
            await asyncio.sleep(random.uniform(0.1, 0.3))
            pyautogui.press('v')
            
        # 3. Post-Paste Verification Pause
        # Humans wait ~0.5s to visually confirm the text appeared
        await asyncio.sleep(random.uniform(0.4, 0.8))
        
    # Final "Commit" Pause
    await asyncio.sleep(random.uniform(0.2, 0.5))
    pyautogui.press('enter')

```

### 2. The "Focus Trap" (Solving the Background Problem)

**The Flaw:** You run `nodriver` on your local machine, but you switch windows to code in VS Code.
**The Detection:** The **Page Visibility API** (`document.visibilityState`) reports `hidden`. If `mousemove` or `keydown` events occur while the page is hidden, it is physically impossible for a human to be the cause. **This is an instant flag.**

**The Software Solution: Virtual Desktops**
You cannot use `headless=True` (it breaks GPU fingerprinting). You must use a **Virtual Desktop** to "jail" the browser. The OS considers the window "active" and "rendered," but it doesn't clutter your main screen.

* **Windows:** Use the `pyvda` library to move the browser window to Desktop #2 programmatically.
* **Linux/macOS:** Use native workspace switchers (e.g., `wmctrl`).

**The Hardware Solution: The "HDMI Dummy Plug"**
For maximum safety, do not run this on your main workstation.

1. Use a cheap Mini-PC (Intel NUC) or Raspberry Pi.
2. Plug in a **4K HDMI Dummy Plug** ($5 dongle) to trick the GPU into rendering a full desktop.
3. Run your `nodriver` API server there.
This ensures 100% valid `document.hasFocus()` metrics without stealing your mouse.

### 3. The "Incidental Hover" (Phantom Interaction)

**The Flaw:** Bots are efficient. They move the mouse from `[Start]` directly to `[Goal]`.
**The Human Reality:** Humans are messy. As we move to click "Send," our cursor inadvertently swipes across the sidebar, previous chat bubbles, or the "Model Selector." These trigger CSS `:hover` states and JS `mouseenter` events that valid sessions are full of.

**The Fix:** Deliberately generate "noise."
Before clicking a target, calculate a path that intersects at least one other clickable element (like a `<div>` or `<a>`) to fire a `mouseenter` event.

### 4. Inertial Scrolling (The "Reading" Pattern)

**The Flaw:** Bots wait for the text to generate, then scrape it instantly.
**The Human Reality:** Humans **chase the stream**. As ChatGPT writes, we scroll down to keep the new text in view. We also use **Inertia** (scroll wheel flicks that decay in speed).

**The Fix:** While the "Stop Generating" button is visible, perform random "scroll chasing."

```python
async def stream_chaser(page):
    """
    Follows the text stream like a human reader.
    """
    while await is_generating(page):
        # 1. Wait for text to fill viewport
        await asyncio.sleep(random.uniform(1.5, 3.0))
        
        # 2. Perform Inertial Scroll (Burst + Decay)
        clicks = random.randint(2, 5)
        for _ in range(clicks):
            pyautogui.scroll(-10) # Down (Negative on most OS)
            time.sleep(random.uniform(0.01, 0.05)) # Wheel notch mechanical delay
            
        # 3. Occasional "Fidget" (Move mouse slightly while reading)
        if random.random() < 0.3:
            pyautogui.moveRel(random.randint(-5, 5), random.randint(-5, 5))

```

### 5. Environmental Consistency (WebRTC)

**The Flaw:** Bots often block WebRTC to hide their IP.
**The Fix:** Since you are running a **Local Shim**, your browser *should* leak your local IP.

* **Do NOT block WebRTC.** Cloudflare compares your HTTP Request IP with your WebRTC Local IP.
* If they match (or map to the same LAN), your "Trust Score" increases. Blocking WebRTC on a residential IP is a "Privacy Tool" signature often associated with abuse.

### Summary of the "Ghost" Stack

| Layer | Technique | Tool / Strategy |
| --- | --- | --- |
| **Cognitive** | Input Gating | Type short, Paste long (`pyperclip`). |
| **Physical** | Inertial Scrolling | Simulate wheel friction; chase the stream. |
| **Noise** | Incidental Hovers | Touch unrelated elements to fire `mouseenter` events. |
| **Environment** | Focus Integrity | Run on Virtual Desktop or HDMI Dummy Plug. |
| **Network** | WebRTC Trust | Allow WebRTC to validate your local execution. |