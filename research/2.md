To prevent CDP detection while using `nodriver`, you must understand that the detection isn't usually triggered by the *presence* of the protocol (browser engineers use it daily), but by the **noise** it generates.

Anti-abuse systems like Arkose Labs and Cloudflare Turnstile fingerprint the CDP by listening for **side effects** in the V8 engine. Specifically, they measure the "serialization latency" (how long it takes the browser to package data to send to your script) and look for "synthetic" input signatures.

Here is the technical strategy to harden `nodriver` and achieve **Radio Silence**.

### 1. The "Silence" Protocol (Code Implementation)

By default, most automation tools enable the `Runtime` and `Log` domains to print console messages to your terminal. **This is a trap.** If `Runtime.enable` is active, the V8 engine has to serialize every console object, creating measurable lag that flags you as a bot.

You must manually disable these domains immediately after the connection is established.

```python
import nodriver as uc

async def stealth_init(page):
    """
    Applies protocol hardening to silence 'chatty' CDP domains 
    that cause V8 serialization latency.
    """
    try:
        # 1. Disable Reporting Domains
        # We want to be "deaf" to the console. This prevents the anti-bot 
        # from spamming complex objects to measure your parsing lag.
        await page.send(uc.cdp.runtime.disable())
        await page.send(uc.cdp.log.disable())
        await page.send(uc.cdp.debugger.disable())
        
        # 2. Defuse "Debugger" Traps
        # Some sites run "debugger;" in a loop. If a devtools client is attached,
        # execution pauses, and their heartbeat script detects the freeze.
        # We tell CDP to ignore all breakpoints.
        await page.send(uc.cdp.debugger.set_breakpoints_active(active=False))
    except Exception:
        # Ignore errors if domains are already disabled
        pass

```

### 2. The "Read-Only" Doctrine

You must strictly separate your interaction into **Passive (Reading)** and **Active (Writing)**.

* **❌ The Danger Zone: `Runtime.evaluate**`
* Avoid using `await page.evaluate("document.querySelector(...)")`.
* **Why:** This forces the `Runtime` domain to re-enable implicitly to execute your JS. It creates a new execution context and stack trace that can be sniffed.


* **✅ The Safe Zone: `DOM.describeNode**`
* Use `await page.select("selector")` or `page.find()`.
* **Why:** `nodriver` implements these using the `DOM` domain, which queries the browser's render tree directly without executing JavaScript in the page context. This is invisible to the page's JS.



### 3. The "Air-Gapped" Input Strategy

The single biggest "tell" is using CDP for input. `Input.dispatchMouseEvent` creates events with `isTrusted: true`, but they lack **hardware entropy** (pressure, sub-pixel jitter, and driver-level interrupts).

**You must use OS-level input (`pyautogui`) for all clicking and typing.**

The challenge is translating **CDP Coordinates** (Viewport) to **OS Coordinates** (Screen).

```python
import asyncio
import random
import nodriver as uc
import pyautogui

# Calibration: Height of your browser's top bar (URL + Tabs) in pixels.
# You must adjust this for your OS/Theme.
BROWSER_CHROME_OFFSET_Y = 80 
BROWSER_CHROME_OFFSET_X = 0

async def human_interact(page, selector, text=None):
    # 1. PASSIVE LOCATE (CDP)
    # Use CDP only to find *where* the element is.
    element = await page.select(selector)
    if not element:
        raise Exception("Element not found")

    # Get bounding box [x, y, width, height] relative to Viewport
    # Note: 'quads' usually returns [x1, y1, x2, y2...]
    quad = element.quads[0]
    viewport_x = (quad[0] + quad[2]) / 2
    viewport_y = (quad[1] + quad[5]) / 2

    # 2. CALIBRATE (Viewport -> Screen)
    # Ensure browser is maximized for this math to work reliably
    screen_x = viewport_x + BROWSER_CHROME_OFFSET_X
    screen_y = viewport_y + BROWSER_CHROME_OFFSET_Y

    # 3. NOISE INJECTION
    # Robots click the exact float center. Humans miss slightly.
    final_x = screen_x + random.randint(-12, 12)
    final_y = screen_y + random.randint(-5, 5)

    # 4. ACTIVE INPUT (OS Level)
    # Move mouse with duration > 0 to generate trajectory data
    pyautogui.moveTo(final_x, final_y, duration=random.uniform(0.2, 0.6))
    pyautogui.click()
    
    if text:
        # Type with inconsistent latency (simulates cognitive pauses)
        await asyncio.sleep(0.5) # Wait for focus
        for char in text:
            pyautogui.write(char)
            await asyncio.sleep(random.uniform(0.04, 0.12))
        pyautogui.press('enter')

async def main():
    # HEADLESS=False is MANDATORY for PyAutoGUI
    browser = await uc.start(headless=False)
    browser.main_tab.maximize() # Standardize coordinates
    
    page = await browser.get("https://chatgpt.com")
    await stealth_init(page) # Apply hardening

    # Wait safely using DOM domain
    await page.wait_for("textarea[id='prompt-textarea']")
    
    # Execute Hybrid Input
    await human_interact(page, "textarea[id='prompt-textarea']", "Hello world")

if __name__ == "__main__":
    uc.loop().run_until_complete(main())

```

### Summary of Tactics

1. **Deaf & Blind:** Keep `Runtime`, `Log`, and `Debugger` domains disabled. If you need to debug, use `print()` in Python, not `console.log` in the browser.
2. **No-Op Input:** Never use `page.click()` or `page.send_keys()`. These are the "loudest" CDP commands.
3. **Visual Fallback:** If coordinate math gets messy (due to varying window borders), use `pyautogui.locateOnScreen('reference_image.png')` to find the chat box visually. It is slower but 100% detached from CDP.
4. **Single Session:** Do not spin up a new browser for every API request. Launch it once, keep it open, and reuse the WebSocket connection. Behavioral analysis flags accounts that log in 50 times a day.